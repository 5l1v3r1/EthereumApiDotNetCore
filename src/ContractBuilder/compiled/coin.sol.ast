PragmaDirective
   Source: "pragma solidity ^0.4.9;"
ContractDefinition "Coin"
   Source: "contract Coin {\r\n\r\n    address _owner;\r\n    address _exchangeContractAddress;\r\n    uint _lastPing;\r\n    mapping (address => uint) public coinBalanceMultisig;\r\n\r\n    event CoinCashIn(address caller, uint amount);\r\n    event CoinCashOut(address caller, address from, uint amount, address to);\r\n    event CoinTransfer(address caller, address from, address to, uint amount);\r\n\r\n    modifier onlyowner { if (msg.sender == _owner) _; }\r\n    modifier onlyFromExchangeContract { if (msg.sender == _exchangeContractAddress || (now - _lastPing) > 30 days) _; }\r\n\r\n    function Coin(address exchangeContractAddress) {\r\n        _owner = msg.sender;\r\n        _exchangeContractAddress = exchangeContractAddress;\r\n    }   \r\n\r\n    function changeExchangeContract(address newContractAddress) onlyFromExchangeContract {\r\n        _exchangeContractAddress = newContractAddress;\r\n    }\r\n\r\n    // transfer coins (called only from exchange contract)\r\n    function transferMultisig(address from, address to, uint amount, bytes32 hash, bytes client_a_sig, bytes params) onlyFromExchangeContract {\r\n        if (!_checkClientSign(from, hash, client_a_sig)) {\r\n            throw;\r\n        }\r\n        if (coinBalanceMultisig[from] < amount) {\r\n            throw;\r\n        }\r\n\r\n        coinBalanceMultisig[from] -= amount;\r\n        coinBalanceMultisig[to] += amount;\r\n\r\n        CoinTransfer(msg.sender, from, to, amount);\r\n    }\r\n\r\n    // virtual method (if not implemented, then throws)\r\n    function cashin(address receiver, uint amount) onlyowner payable { throw; }\r\n\r\n    // virtual method (if not implemented, then throws)\r\n    function cashout(address from, address to, uint amount, bytes32 hash, bytes client_sig, bytes params) onlyFromExchangeContract { throw; }\r\n\r\n    function _checkClientSign(address client_addr, bytes32 hash, bytes sig) returns(bool) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := mload(add(sig, 65))\r\n        }\r\n\r\n        return client_addr == ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function ping() {\r\n        _lastPing = now;\r\n    }\r\n}"
  VariableDeclaration "_owner"
     Type: address
     Source: "address _owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "_exchangeContractAddress"
     Type: address
     Source: "address _exchangeContractAddress"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "_lastPing"
     Type: uint256
     Source: "uint _lastPing"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "coinBalanceMultisig"
     Type: mapping(address => uint256)
     Source: "mapping (address => uint) public coinBalanceMultisig"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  EventDefinition "CoinCashIn"
     Source: "event CoinCashIn(address caller, uint amount);"
    ParameterList
       Source: "(address caller, uint amount)"
      VariableDeclaration "caller"
         Type: address
         Source: "address caller"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "CoinCashOut"
     Source: "event CoinCashOut(address caller, address from, uint amount, address to);"
    ParameterList
       Source: "(address caller, address from, uint amount, address to)"
      VariableDeclaration "caller"
         Type: address
         Source: "address caller"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
  EventDefinition "CoinTransfer"
     Source: "event CoinTransfer(address caller, address from, address to, uint amount);"
    ParameterList
       Source: "(address caller, address from, address to, uint amount)"
      VariableDeclaration "caller"
         Type: address
         Source: "address caller"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  ModifierDefinition "onlyowner"
     Source: "modifier onlyowner { if (msg.sender == _owner) _; }"
    ParameterList
       Source: ""
    Block
       Source: "{ if (msg.sender == _owner) _; }"
      IfStatement
         Source: "if (msg.sender == _owner) _"
        BinaryOperation using operator ==
           Type: bool
           Source: "msg.sender == _owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _owner
             Type: address
             Source: "_owner"
        PlaceholderStatement
           Source: "_"
  ModifierDefinition "onlyFromExchangeContract"
     Source: "modifier onlyFromExchangeContract { if (msg.sender == _exchangeContractAddress || (now - _lastPing) > 30 days) _; }"
    ParameterList
       Source: ""
    Block
       Source: "{ if (msg.sender == _exchangeContractAddress || (now - _lastPing) > 30 days) _; }"
      IfStatement
         Source: "if (msg.sender == _exchangeContractAddress || (now - _lastPing) > 30 days) _"
        BinaryOperation using operator ||
           Type: bool
           Source: "msg.sender == _exchangeContractAddress || (now - _lastPing) > 30 days"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == _exchangeContractAddress"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _exchangeContractAddress
               Type: address
               Source: "_exchangeContractAddress"
          BinaryOperation using operator >
             Type: bool
             Source: "(now - _lastPing) > 30 days"
            TupleExpression
               Type: uint256
               Source: "(now - _lastPing)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "now - _lastPing"
                Identifier now
                   Type: uint256
                   Source: "now"
                Identifier _lastPing
                   Type: uint256
                   Source: "_lastPing"
            Literal, token: [no token] value: 30
               Type: int_const 2592000
               Source: "30 days"
        PlaceholderStatement
           Source: "_"
  FunctionDefinition "Coin" - public
     Source: "function Coin(address exchangeContractAddress) {\r\n        _owner = msg.sender;\r\n        _exchangeContractAddress = exchangeContractAddress;\r\n    }"
    ParameterList
       Source: "(address exchangeContractAddress)"
      VariableDeclaration "exchangeContractAddress"
         Type: address
         Source: "address exchangeContractAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        _owner = msg.sender;\r\n        _exchangeContractAddress = exchangeContractAddress;\r\n    }"
      ExpressionStatement
         Source: "_owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "_owner = msg.sender"
          Identifier _owner
             Type: address
             Source: "_owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "_exchangeContractAddress = exchangeContractAddress"
        Assignment using operator =
           Type: address
           Source: "_exchangeContractAddress = exchangeContractAddress"
          Identifier _exchangeContractAddress
             Type: address
             Source: "_exchangeContractAddress"
          Identifier exchangeContractAddress
             Type: address
             Source: "exchangeContractAddress"
  FunctionDefinition "changeExchangeContract" - public
     Source: "function changeExchangeContract(address newContractAddress) onlyFromExchangeContract {\r\n        _exchangeContractAddress = newContractAddress;\r\n    }"
    ParameterList
       Source: "(address newContractAddress)"
      VariableDeclaration "newContractAddress"
         Type: address
         Source: "address newContractAddress"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
    ModifierInvocation "onlyFromExchangeContract"
       Source: "onlyFromExchangeContract"
      Identifier onlyFromExchangeContract
         Type: modifier ()
         Source: "onlyFromExchangeContract"
    Block
       Source: "{\r\n        _exchangeContractAddress = newContractAddress;\r\n    }"
      ExpressionStatement
         Source: "_exchangeContractAddress = newContractAddress"
        Assignment using operator =
           Type: address
           Source: "_exchangeContractAddress = newContractAddress"
          Identifier _exchangeContractAddress
             Type: address
             Source: "_exchangeContractAddress"
          Identifier newContractAddress
             Type: address
             Source: "newContractAddress"
  FunctionDefinition "transferMultisig" - public
     Source: "function transferMultisig(address from, address to, uint amount, bytes32 hash, bytes client_a_sig, bytes params) onlyFromExchangeContract {\r\n        if (!_checkClientSign(from, hash, client_a_sig)) {\r\n            throw;\r\n        }\r\n        if (coinBalanceMultisig[from] < amount) {\r\n            throw;\r\n        }\r\n\r\n        coinBalanceMultisig[from] -= amount;\r\n        coinBalanceMultisig[to] += amount;\r\n\r\n        CoinTransfer(msg.sender, from, to, amount);\r\n    }"
    ParameterList
       Source: "(address from, address to, uint amount, bytes32 hash, bytes client_a_sig, bytes params)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "client_a_sig"
         Type: bytes memory
         Source: "bytes client_a_sig"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "params"
         Type: bytes memory
         Source: "bytes params"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
    ModifierInvocation "onlyFromExchangeContract"
       Source: "onlyFromExchangeContract"
      Identifier onlyFromExchangeContract
         Type: modifier ()
         Source: "onlyFromExchangeContract"
    Block
       Source: "{\r\n        if (!_checkClientSign(from, hash, client_a_sig)) {\r\n            throw;\r\n        }\r\n        if (coinBalanceMultisig[from] < amount) {\r\n            throw;\r\n        }\r\n\r\n        coinBalanceMultisig[from] -= amount;\r\n        coinBalanceMultisig[to] += amount;\r\n\r\n        CoinTransfer(msg.sender, from, to, amount);\r\n    }"
      IfStatement
         Source: "if (!_checkClientSign(from, hash, client_a_sig)) {\r\n            throw;\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Source: "!_checkClientSign(from, hash, client_a_sig)"
          FunctionCall
             Type: bool
             Source: "_checkClientSign(from, hash, client_a_sig)"
            Identifier _checkClientSign
               Type: function (address,bytes32,bytes memory) returns (bool)
               Source: "_checkClientSign"
            Identifier from
               Type: address
               Source: "from"
            Identifier hash
               Type: bytes32
               Source: "hash"
            Identifier client_a_sig
               Type: bytes memory
               Source: "client_a_sig"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Source: "throw"
      IfStatement
         Source: "if (coinBalanceMultisig[from] < amount) {\r\n            throw;\r\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "coinBalanceMultisig[from] < amount"
          IndexAccess
             Type: uint256
             Source: "coinBalanceMultisig[from]"
            Identifier coinBalanceMultisig
               Type: mapping(address => uint256)
               Source: "coinBalanceMultisig"
            Identifier from
               Type: address
               Source: "from"
          Identifier amount
             Type: uint256
             Source: "amount"
        Block
           Source: "{\r\n            throw;\r\n        }"
          Throw
             Source: "throw"
      ExpressionStatement
         Source: "coinBalanceMultisig[from] -= amount"
        Assignment using operator -=
           Type: uint256
           Source: "coinBalanceMultisig[from] -= amount"
          IndexAccess
             Type: uint256
             Source: "coinBalanceMultisig[from]"
            Identifier coinBalanceMultisig
               Type: mapping(address => uint256)
               Source: "coinBalanceMultisig"
            Identifier from
               Type: address
               Source: "from"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Source: "coinBalanceMultisig[to] += amount"
        Assignment using operator +=
           Type: uint256
           Source: "coinBalanceMultisig[to] += amount"
          IndexAccess
             Type: uint256
             Source: "coinBalanceMultisig[to]"
            Identifier coinBalanceMultisig
               Type: mapping(address => uint256)
               Source: "coinBalanceMultisig"
            Identifier to
               Type: address
               Source: "to"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Source: "CoinTransfer(msg.sender, from, to, amount)"
        FunctionCall
           Type: tuple()
           Source: "CoinTransfer(msg.sender, from, to, amount)"
          Identifier CoinTransfer
             Type: function (address,address,address,uint256) constant
             Source: "CoinTransfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier from
             Type: address
             Source: "from"
          Identifier to
             Type: address
             Source: "to"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "cashin" - public
     Source: "function cashin(address receiver, uint amount) onlyowner payable { throw; }"
    ParameterList
       Source: "(address receiver, uint amount)"
      VariableDeclaration "receiver"
         Type: address
         Source: "address receiver"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
    ModifierInvocation "onlyowner"
       Source: "onlyowner"
      Identifier onlyowner
         Type: modifier ()
         Source: "onlyowner"
    Block
       Source: "{ throw; }"
      Throw
         Source: "throw"
  FunctionDefinition "cashout" - public
     Source: "function cashout(address from, address to, uint amount, bytes32 hash, bytes client_sig, bytes params) onlyFromExchangeContract { throw; }"
    ParameterList
       Source: "(address from, address to, uint amount, bytes32 hash, bytes client_sig, bytes params)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "client_sig"
         Type: bytes memory
         Source: "bytes client_sig"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "params"
         Type: bytes memory
         Source: "bytes params"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
    ModifierInvocation "onlyFromExchangeContract"
       Source: "onlyFromExchangeContract"
      Identifier onlyFromExchangeContract
         Type: modifier ()
         Source: "onlyFromExchangeContract"
    Block
       Source: "{ throw; }"
      Throw
         Source: "throw"
  FunctionDefinition "_checkClientSign" - public
     Source: "function _checkClientSign(address client_addr, bytes32 hash, bytes sig) returns(bool) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := mload(add(sig, 65))\r\n        }\r\n\r\n        return client_addr == ecrecover(hash, v, r, s);\r\n    }"
    ParameterList
       Source: "(address client_addr, bytes32 hash, bytes sig)"
      VariableDeclaration "client_addr"
         Type: address
         Source: "address client_addr"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "hash"
         Type: bytes32
         Source: "bytes32 hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "sig"
         Type: bytes memory
         Source: "bytes sig"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := mload(add(sig, 65))\r\n        }\r\n\r\n        return client_addr == ecrecover(hash, v, r, s);\r\n    }"
      VariableDeclarationStatement
         Source: "bytes32 r;"
        VariableDeclaration "r"
           Type: bytes32
           Source: "bytes32 r"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Source: "bytes32 s;"
        VariableDeclaration "s"
           Type: bytes32
           Source: "bytes32 s"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Source: "uint8 v;"
        VariableDeclaration "v"
           Type: uint8
           Source: "uint8 v"
          ElementaryTypeName uint8
             Source: "uint8"
      InlineAssembly
         Source: "assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := mload(add(sig, 65))\r\n        }\r\n\r\n        return"
      Return
         Source: "return client_addr == ecrecover(hash, v, r, s)"
        BinaryOperation using operator ==
           Type: bool
           Source: "client_addr == ecrecover(hash, v, r, s)"
          Identifier client_addr
             Type: address
             Source: "client_addr"
          FunctionCall
             Type: address
             Source: "ecrecover(hash, v, r, s)"
            Identifier ecrecover
               Type: function (bytes32,uint8,bytes32,bytes32) returns (address)
               Source: "ecrecover"
            Identifier hash
               Type: bytes32
               Source: "hash"
            Identifier v
               Type: uint8
               Source: "v"
            Identifier r
               Type: bytes32
               Source: "r"
            Identifier s
               Type: bytes32
               Source: "s"
  FunctionDefinition "ping" - public
     Source: "function ping() {\r\n        _lastPing = now;\r\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        _lastPing = now;\r\n    }"
      ExpressionStatement
         Source: "_lastPing = now"
        Assignment using operator =
           Type: uint256
           Source: "_lastPing = now"
          Identifier _lastPing
             Type: uint256
             Source: "_lastPing"
          Identifier now
             Type: uint256
             Source: "now"
